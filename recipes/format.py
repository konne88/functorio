#!/usr/bin/env python3

import json

def to_camel_case(kebab_case_str: str) -> str:
    """Converts a kebab-case string to camelCase.
    
    Example: "iron-chest" -> "ironChest"
    """
    parts = kebab_case_str.split('-')
    return parts[0] + ''.join(x.capitalize() for x in parts[1:])

def generate_lean_from_json(json_path: str, lean_path: str):
    """
    Parses a JSON recipe file and generates a corresponding Lean file.

    Args:
        json_path (str): The path to the input JSON file.
        lean_path (str): The path for the output .lean file.
    """
    try:
        with open(json_path, 'r') as f:
            recipes_data = json.load(f)
    except FileNotFoundError:
        print(f"Error: Input file not found at '{json_path}'")
        return
    except json.JSONDecodeError:
        print(f"Error: Could not parse JSON from '{json_path}'. Check for syntax errors.")
        return

    # --- 1. Collect all unique ingredients and recipe names ---
    all_ingredients = set()
    recipe_names = list(recipes_data.keys())

    for recipe in recipes_data.values():
        for ingredient in recipe.get('ingredients', []):
            all_ingredients.add(ingredient['name'])
        for product in recipe.get('products', []):
            all_ingredients.add(product['name'])

    # --- 2. Build the Lean file content as a list of strings ---
    lean_code = []

    # Ingredient inductive type
    lean_code.append("inductive Ingredient")
    for ingredient in sorted(list(all_ingredients)):
        lean_code.append(f"  | {to_camel_case(ingredient)}")
    lean_code.append("  deriving DecidableEq, Repr, Inhabited\n")

    # Static Recipe structure (copied from your example)
    lean_code.append("""
structure Recipe where
  name: Option String
  -- The `Fraction` indicates how many items are needed to execute the recipe.
  inputs : List (Fraction × Ingredient)
  -- The `Fraction` indicates how many output items are generated by executing the recipe.
  outputs : List (Fraction × Ingredient)
  -- Number of seconds that it takes the user to execute the recipe.
  time : Fraction
  deriving DecidableEq, Repr, Inhabited
""")

    # RecipeName inductive type
    lean_code.append("inductive RecipeName")
    for name in sorted(recipe_names):
        lean_code.append(f"  | {to_camel_case(name)}")
    lean_code.append("  deriving DecidableEq, Repr, Inhabited\n")

    # getRecipe function definition
    lean_code.append("def getRecipe : RecipeName → Recipe")
    for i, name in enumerate(sorted(recipe_names)):
        recipe = recipes_data[name]
        camel_case_name = to_camel_case(name)
        
        # Start the case
        prefix = "| " if i == 0 else "| "
        lean_code.append(f"{prefix}.{camel_case_name} => {{")
        
        # Add fields
        lean_code.append(f'  name := some "{name}",')

        # Inputs
        inputs_list = [
            f"({ing['amount']}, .{to_camel_case(ing['name'])})"
            for ing in recipe.get('ingredients', [])
        ]
        lean_code.append(f"  inputs := [{', '.join(inputs_list)}],")

        # Outputs
        outputs_list = [
            f"({prod['amount']}, .{to_camel_case(prod['name'])})"
            for prod in recipe.get('products', [])
        ]
        lean_code.append(f"  outputs := [{', '.join(outputs_list)}],")

        # Time
        lean_code.append(f"  time := {recipe.get('energy', 0)}")
        lean_code.append("}")

    # --- 3. Write the content to the output file ---
    try:
        with open(lean_path, 'w') as f:
            f.write('\n'.join(lean_code))
        print(f"✅ Successfully generated Lean file at '{lean_path}'")
    except IOError as e:
        print(f"Error writing to file '{lean_path}': {e}")


if __name__ == "__main__":
    # Assuming your JSON file is named 'recipes.json'
    # The output will be 'generated_recipes.lean'
    generate_lean_from_json('recipes.json', 'generated_recipes.lean')
