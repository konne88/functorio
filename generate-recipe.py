#!/usr/bin/env python3

# Generates the Recipe.lean file from a factorio data dump, get it by passing --dump-data to factorio

from fractions import Fraction
import json

def to_camel_case(kebab_case_str: str) -> str:
    parts = kebab_case_str.split('-')
    return parts[0] + ''.join(x.capitalize() for x in parts[1:])

def float_to_fraction(f: float) -> str:
    return str(Fraction(f).limit_denominator(1000)) 

with open('data-raw-dump.json', 'r') as f:
    data = json.load(f)

buildings_data = data['assembling-machine'] | data['furnace'] | data['rocket-silo']
recipes_data = data['recipe']
ingredients_data = data['item'] | data['ammo'] | data['fluid'] | data['item-with-entity-data'] | data['tool'] | data['capsule'] | data['gun'] | data['module'] | data['armor']

recipe_names = [key for key in recipes_data.keys() if key != "recipe-unknown"]
building_names = list(buildings_data.keys())
ingredient_names = set()
categories = set() 

for name in recipe_names:
    recipe = recipes_data[name]
    categories.add(recipe.get('category', 'crafting'))

    for ingredient in recipe.get('ingredients', []):
        ingredient_names.add(ingredient['name'])

    for ingredient in recipe.get('results', []):
        ingredient_names.add(ingredient['name'])
  
for building in buildings_data.values():
    for category in building["crafting_categories"]:
        categories.add(category)

# Build the Lean file content as a list of strings
lean_code = []

# Header
lean_code.append("-- Generated by generate-recipe.py. Do not modify.\n")
lean_code.append("import Functorio.Fraction\n")
lean_code.append("import Functorio.Direction\n")

# Ingredient inductive type
lean_code.append("inductive Ingredient")
for ingredient in sorted(ingredient_names):
    lean_code.append(f"  | {to_camel_case(ingredient)}")
lean_code.append("  deriving DecidableEq, Repr, Inhabited\n")

# Categories inductive type
lean_code.append("inductive RecipeCategory")
for category in sorted(list(categories)):
    lean_code.append(f"  | {to_camel_case(category)}")
lean_code.append("  deriving DecidableEq, Repr, Inhabited\n")

# isLiquid function
lean_code.append("namespace Ingredient\n")
lean_code.append("def isLiquid : Ingredient -> Bool")
for name in sorted(list(ingredient_names)):
    if ingredients_data.get(name, {}).get('type') == 'fluid':
        lean_code.append(f"| .{to_camel_case(name)} => true")
lean_code.append(f"| _ => false\n")

lean_code.append("def spoilResult : Ingredient -> Option Ingredient")
for name in sorted(list(ingredient_names)):
    try:
        spoil_result = ingredients_data[name]['spoil_result']
        lean_code.append(f"| .{to_camel_case(name)} => .some {to_camel_case(spoil_result)}")
    except Exception:
        continue
lean_code.append(f"| _ => .none\n")

lean_code.append("def name : Ingredient -> String")
for name in sorted(ingredient_names):
    lean_code.append(f'| .{to_camel_case(name)} => "{name}"')

lean_code.append("\nend Ingredient")

# Static Recipe structure
lean_code.append("""
structure Recipe where
  name: String
  -- The `Fraction` indicates how many items are needed to execute the recipe.
  inputs : List (Fraction × Ingredient)
  -- The `Fraction` indicates how many output items are generated by executing the recipe.
  outputs : List (Fraction × Ingredient)
  category : RecipeCategory
  -- Number of seconds that it takes the user to execute the recipe.
  time : Fraction
  deriving DecidableEq, Repr, Inhabited

inductive FluidBoxType where
  | input
  | output
  | inputOutput
  deriving DecidableEq, Repr, Inhabited

structure FluidBox where
  side: Direction
  offset: Nat
  type: FluidBoxType
  deriving DecidableEq, Repr, Inhabited

structure FabricatorDetails where
  name : String
  width : Nat
  height : Nat
  speedup : Fraction
  productivity : Fraction
  moduleSlots : Nat
  fluidBoxes : List FluidBox
  categories : List RecipeCategory
  deriving DecidableEq, Repr, Inhabited
""")

# RecipeName inductive type
lean_code.append("inductive RecipeName")
for name in sorted(recipe_names):
    lean_code.append(f"  | {to_camel_case(name)}")
lean_code.append("  deriving DecidableEq, Repr, Inhabited\n")

# getRecipe function definition
lean_code.append("namespace RecipeName\n")
lean_code.append("def getRecipe : RecipeName -> Recipe")
for name in sorted(recipe_names):
    recipe = recipes_data[name]
    camel_case_name = to_camel_case(name)
    try:
        inputs = recipe.get('ingredients', [])
        outputs = recipe.get('results', [])
        category = recipe.get('category', 'crafting')
        time = recipe.get('energy_required', 0.5)
    except Exception as e:
        print(f"{name} not supported because of {e}")

    # sort fluids before solids    
    inputs = [i for i in inputs if i['type'] == 'fluid'] + \
             [i for i in inputs if i['type'] != 'fluid'] 

    # large solid outputs come first
    solidOutputs = [i for i in outputs if i['type'] != 'fluid']
    solidOutputs.sort(reverse=True, key=lambda a: a['amount'])
    liquidOutputs = [i for i in outputs if i['type'] == 'fluid']

    outputs = solidOutputs + liquidOutputs

    # Rocket parts cannot be removed from the rocket silo.
    if name == "rocket-part":
        outputs = []

    lean_code.append(f"| .{camel_case_name} => {{")
    lean_code.append(f'  name := "{name}",')

    inputs_list = [
        f"({float_to_fraction(ingredient['amount'])}, .{to_camel_case(ingredient['name'])})"
        for ingredient in inputs
    ]
    lean_code.append(f"  inputs := [{', '.join(inputs_list)}],")

    outputs_list = [
        f"({float_to_fraction(product['amount'] * product.get('probability', 1))}, .{to_camel_case(product['name'])})"
        for product in outputs
    ]
    lean_code.append(f"  outputs := [{', '.join(outputs_list)}],")
    
    lean_code.append(f"  category := .{to_camel_case(category)}")
    lean_code.append(f"  time := {float_to_fraction(time)}")
    
    lean_code.append("}")
    
lean_code.append("\nend RecipeName\n")

# Fabricators
lean_code.append("inductive Fabricator")
for building_name in sorted(building_names):
    building = buildings_data[building_name]
    lean_code.append(f"  | {to_camel_case(building['name'])}")
lean_code.append("  deriving DecidableEq, Repr, Inhabited\n")

# Fabricator details
lean_code.append("namespace Fabricator\n")

lean_code.append("@[simp]")
lean_code.append("def details : Fabricator -> FabricatorDetails")
for building_name in sorted(building_names):
    building = buildings_data[building_name]
    ((x0,y0),(x1,y1)) = building["selection_box"]
    productivity = building.get('effect_receiver', {}).get("base_effect", {}).get("productivity", 0)

    lean_code.append(f"| .{to_camel_case(building['name'])} => {{")
    lean_code.append(f'  name := "{building["name"]}"')
    lean_code.append(f"  speedup := {float_to_fraction(building['crafting_speed'])}")
    lean_code.append(f"  productivity := {float_to_fraction(productivity)}")
    lean_code.append(f"  moduleSlots := {building.get('module_slots', 0)}")
    lean_code.append(f"  width := {int(x1 - x0)}")
    lean_code.append(f"  height := {int(y1 - y0)}")    

    lean_code.append(f"  fluidBoxes := [")
    for box in building.get("fluid_boxes", []):
        info = box["pipe_connections"][0]
        dir = {0: 'N', 4: 'E', 8: 'S', 12: 'W'}[info['direction']]
        (x,y) = info["position"]
        offset = int({
            'N': x - x0 - 0.5,
            'E': y - y0 - 0.5,
            'S': x - x0 - 0.5,
            'W': y - y0 - 0.5,
        }[dir])
        lean_code.append("    {")
        lean_code.append(f"      offset := {offset}")
        lean_code.append(f"      side := .{dir}")
        lean_code.append(f"      type := .{to_camel_case(info['flow_direction'])}")
        lean_code.append("    },")
    lean_code.append("  ]")
    
    lean_code.append(f"  categories := [")
    for category in sorted(building["crafting_categories"]):
        lean_code.append(f"    .{to_camel_case(category)},")
    lean_code.append("  ]")
    lean_code.append("}")

lean_code.append("""
def name (f:Fabricator) := f.details.name

def width (f:Fabricator) := f.details.width

def height (f:Fabricator) := f.details.height

@[simp]
def speedup (f:Fabricator) := f.details.speedup

@[simp]
def productivity (f:Fabricator) := f.details.productivity

@[simp]
def moduleSlots (f:Fabricator) := f.details.moduleSlots

def fluidBoxes (f:Fabricator) := f.details.fluidBoxes

def handlesCategory (f:Fabricator) (c:RecipeCategory) :=
  f.details.categories.contains c
  
end Fabricator
""")

# Write the content to the output file
file = "Functorio/Recipe.lean"
with open(file, 'w') as f:
    f.write('\n'.join(lean_code))

print(f"✅ Successfully generated Lean file at '{file}'")
